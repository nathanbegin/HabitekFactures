import os
import psycopg2
from psycopg2 import sql
from urllib.parse import urlparse, unquote

# --------------------------------------------------------------------
# 1) Paramètres
# --------------------------------------------------------------------
DATABASE_URL = os.environ.get(
    "DATABASE_URL",
    "postgresql://minio:Habitek2025@localhost:5432/habitek_tresorerie"
)

parsed = urlparse(DATABASE_URL)
pg_user = unquote(parsed.username) if parsed.username else None
pg_pass = unquote(parsed.password) if parsed.password else None
pg_host = parsed.hostname or "localhost"
pg_port = parsed.port or 5432
pg_db   = (parsed.path or "/").lstrip("/") or "habitek_tresorerie"

def connect_db(dbname: str):
    return psycopg2.connect(
        dbname=dbname,
        user=pg_user,
        password=pg_pass,
        host=pg_host,
        port=pg_port,
    )

# --------------------------------------------------------------------
# 2) DDL — domaines, types, tables, index, fonctions & triggers
# --------------------------------------------------------------------
DDL_BLOCKS = [

# =========================
# Domaines & Types
# =========================

# Enum statut facture
"""
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'invoice_status') THEN
    CREATE TYPE invoice_status AS ENUM ('brouillon','soumise','approuvée','payée','rejetée');
  END IF;
END $$;
""",

# Code monnaie ISO 4217, 3 lettres
"""
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'currency_iso') THEN
    CREATE DOMAIN currency_iso AS varchar(3)
      CHECK (VALUE ~ '^[A-Z]{3}$');
  END IF;
END $$;
""",

# Email basique
"""
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_addr') THEN
    CREATE DOMAIN email_addr AS varchar(320)
      CHECK (VALUE ~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$');
  END IF;
END $$;
""",

# Code postal canadien (A1A 1A1) espace facultatif
"""
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ca_postal') THEN
    CREATE DOMAIN ca_postal AS varchar(7)
      CHECK (VALUE ~* '^[ABCEGHJ-NPRSTVXY]\\d[ABCEGHJ-NPRSTV-Z][ ]?\\d[ABCEGHJ-NPRSTV-Z]\\d$');
  END IF;
END $$;
""",

# =========================
# Tables de données
# =========================

# Budgets
"""
CREATE TABLE IF NOT EXISTS budgets (
  id              serial PRIMARY KEY,
  financial_year  varchar(4),
  fund_type       varchar(50),
  revenue_type    varchar(255),
  amount          numeric(10,2),
  date_added      timestamp DEFAULT now()
);
""",

# Utilisateurs
"""
CREATE TABLE IF NOT EXISTS app_user (
  uid              integer GENERATED BY DEFAULT AS IDENTITY (START WITH 0) PRIMARY KEY,
  prénom           varchar(1000) NOT NULL,
  nom              varchar(1000) NOT NULL,
  courriel         email_addr UNIQUE,
  code_permanent   varchar(254),
  adresse          varchar(1000),
  ville            varchar(1000),
  code_postal      ca_postal,
  province         varchar(1000),
  mode_préf_remb   smallint,
  fonction         varchar(1000),
  rôle             varchar(1000),
  CHECK (mode_préf_remb IS NULL OR mode_préf_remb IN (1,2)),
  CHECK (uid BETWEEN 1 AND 1000)
);
""",

# Factures
"""
CREATE TABLE IF NOT EXISTS factures (
  id               bigserial PRIMARY KEY,
  fid              text UNIQUE,                          -- FYYYY-XXX (auto)
  financial_year   integer,                              -- calculé, utile pour filtres/rapports
  date_facture     timestamptz NOT NULL,
  date_soumise     timestamptz DEFAULT now(),
  fournisseur      varchar(1000) NOT NULL,
  description      varchar(1000),
  montant          numeric(12,2) CHECK (montant >= 0),
  devise           currency_iso,
  statut           invoice_status,
  catégorie        varchar(255),
  ligne_budgetaire varchar(255),
  type             varchar(255),
  ubr              varchar(255),
  poste_budgetaire varchar(255),
  CHECK (fid IS NULL OR fid ~ '^F[0-9]{4}-[0-9]{3}$')
);
""",

# Comptes de dépenses
"""
CREATE TABLE IF NOT EXISTS compte_depenses (
  id                bigserial PRIMARY KEY,
  cid               text UNIQUE,                         -- CYYYY-HABITEKXXX (auto)
  financial_year    integer,                             -- calculé
  date_soumis       timestamptz DEFAULT now(),
  mode              varchar(255),
  type_cdd_int      smallint,                            -- 1 = voyage, 0 = autre
  prénom_demandeur  varchar(1000) NOT NULL,
  nom_demandeur     varchar(1000) NOT NULL,
  CHECK (type_cdd_int IS NULL OR type_cdd_int IN (0,1)),
  CHECK (cid IS NULL OR cid ~ '^C[0-9]{4}-HABITEK[0-9]{3}$')
);
""",

# Notes de rapport de dépenses
"""
CREATE TABLE IF NOT EXISTS notes_rdd (
  note_id       bigserial PRIMARY KEY,
  expense_pk    bigint REFERENCES compte_depenses(id) ON DELETE CASCADE,
  auteur_uid    int    REFERENCES app_user(uid) ON DELETE SET NULL,
  texte_note    text,
  date_création timestamptz DEFAULT now()
);
""",

# Pièces jointes Factures
"""
CREATE TABLE IF NOT EXISTS factures_pj (
  invoice_pk  bigint REFERENCES factures(id) ON DELETE CASCADE,
  file_index  int CHECK (file_index >= 1),
  file_path   text,
  uploaded_at timestamptz DEFAULT now(),
  PRIMARY KEY (invoice_pk, file_index)
);
""",

# Pièces jointes Comptes
"""
CREATE TABLE IF NOT EXISTS factures_cdd (
  expense_pk  bigint REFERENCES compte_depenses(id) ON DELETE CASCADE,
  file_index  int CHECK (file_index >= 1),
  file_path   text,
  uploaded_at timestamptz DEFAULT now(),
  PRIMARY KEY (expense_pk, file_index)
);
""",

# =========================
# Index utiles
# =========================
"CREATE INDEX IF NOT EXISTS idx_factures_fid ON factures(fid);",
"CREATE INDEX IF NOT EXISTS idx_compte_depenses_cid ON compte_depenses(cid);",
"CREATE INDEX IF NOT EXISTS idx_factures_finyr ON factures(financial_year);",
"CREATE INDEX IF NOT EXISTS idx_cdd_finyr ON compte_depenses(financial_year);",

# =========================
# Métadonnées & Compteurs
# =========================

# Table de paramètres généraux (si besoin plus tard)
"""
CREATE TABLE IF NOT EXISTS general_settings (
  key text PRIMARY KEY,
  value text
);
""",

# Compteurs par type et année financière (persistants)
"""
CREATE TABLE IF NOT EXISTS id_counters (
  counter_type text NOT NULL,          -- 'facture' ou 'cdd'
  financial_year integer NOT NULL,     -- ex: 2025
  next_index integer NOT NULL DEFAULT 1,
  PRIMARY KEY (counter_type, financial_year)
);
""",

# =========================
# Fonctions utilitaires
# =========================

# Fonction: détermine l'année financière (1 mai -> 30 avril)
"""
CREATE OR REPLACE FUNCTION fiscal_year_of(ts timestamptz)
RETURNS integer
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  y int := date_part('year', ts)::int;
  m int := date_part('month', ts)::int;
BEGIN
  -- Si mois >= mai (5), année financière = année en cours, sinon = année - 1
  IF m >= 5 THEN
    RETURN y;
  ELSE
    RETURN y - 1;
  END IF;
END;
$$;
""",

# Fonction: récupère et incrémente un compteur atomiquement
"""
CREATE OR REPLACE FUNCTION next_counter(p_counter_type text, p_year integer)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
  v_next int;
BEGIN
  LOOP
    -- Tente d'update si la ligne existe
    UPDATE id_counters
       SET next_index = next_index + 1
     WHERE counter_type = p_counter_type
       AND financial_year = p_year
     RETURNING next_index - 1 INTO v_next;

    IF FOUND THEN
      RETURN v_next;  -- on retourne l'ancien next_index (valeur à utiliser)
    END IF;

    -- Sinon, essaie d'insérer la ligne (1er index = 1)
    BEGIN
      INSERT INTO id_counters(counter_type, financial_year, next_index)
      VALUES (p_counter_type, p_year, 2); -- on prépare le prochain à 2, on retournera 1
      RETURN 1;
    EXCEPTION WHEN unique_violation THEN
      -- Concurrence : une autre transaction vient de créer la ligne -> on boucle
    END;
  END LOOP;
END;
$$;
""",

# =========================
# Triggers: Factures
# =========================

# BEFORE INSERT/UPDATE pour générer fid & financial_year, et empêcher modif fid
"""
CREATE OR REPLACE FUNCTION trg_factures_biu()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_year int;
  v_idx int;
BEGIN
  -- Calcul de l'année financière à partir de date_facture (ou maintenant si NULL)
  IF NEW.date_facture IS NULL THEN
    NEW.date_facture := now();
  END IF;
  v_year := fiscal_year_of(NEW.date_facture);
  NEW.financial_year := v_year;

  -- Génération du fid uniquement à l'INSERT si NULL
  IF TG_OP = 'INSERT' THEN
    IF NEW.fid IS NULL OR NEW.fid = '' THEN
      v_idx := next_counter('facture', v_year);
      NEW.fid := 'F' || v_year::text || '-' || lpad(v_idx::text, 3, '0');
    END IF;
  ELSIF TG_OP = 'UPDATE' THEN
    -- Interdit la modification de fid
    IF NEW.fid IS DISTINCT FROM OLD.fid THEN
      RAISE EXCEPTION 'Modification de fid interdite (ancien=%, nouveau=%)', OLD.fid, NEW.fid;
    END IF;
  END IF;

  -- Validation regex finale (au cas où fid fourni manuellement)
  IF NEW.fid IS NOT NULL AND NEW.fid !~ '^F[0-9]{4}-[0-9]{3}$' THEN
    RAISE EXCEPTION 'fid invalide: % (attendu FYYYY-XXX)', NEW.fid;
  END IF;

  RETURN NEW;
END;
$$;
""",
"DROP TRIGGER IF EXISTS t_factures_biu ON factures;",
"CREATE TRIGGER t_factures_biu BEFORE INSERT OR UPDATE ON factures FOR EACH ROW EXECUTE FUNCTION trg_factures_biu();",

# =========================
# Triggers: Comptes de dépenses (CDD)
# =========================

# BEFORE INSERT/UPDATE pour générer cid & financial_year, et empêcher modif cid
"""
CREATE OR REPLACE FUNCTION trg_cdd_biu()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_year int;
  v_idx int;
BEGIN
  -- Année financière depuis date_soumis (ou maintenant si NULL)
  IF NEW.date_soumis IS NULL THEN
    NEW.date_soumis := now();
  END IF;
  v_year := fiscal_year_of(NEW.date_soumis);
  NEW.financial_year := v_year;

  -- Génération du cid uniquement à l'INSERT si NULL
  IF TG_OP = 'INSERT' THEN
    IF NEW.cid IS NULL OR NEW.cid = '' THEN
      v_idx := next_counter('cdd', v_year);
      NEW.cid := 'C' || v_year::text || '-HABITEK' || lpad(v_idx::text, 3, '0');
    END IF;
  ELSIF TG_OP = 'UPDATE' THEN
    -- Interdit la modification de cid
    IF NEW.cid IS DISTINCT FROM OLD.cid THEN
      RAISE EXCEPTION 'Modification de cid interdite (ancien=%, nouveau=%)', OLD.cid, NEW.cid;
    END IF;
  END IF;

  -- Validation regex finale (au cas où cid fourni manuellement)
  IF NEW.cid IS NOT NULL AND NEW.cid !~ '^C[0-9]{4}-HABITEK[0-9]{3}$' THEN
    RAISE EXCEPTION 'cid invalide: % (attendu CYYYY-HABITEKXXX)', NEW.cid;
  END IF;

  RETURN NEW;
END;
$$;
""",
"DROP TRIGGER IF EXISTS t_cdd_biu ON compte_depenses;",
"CREATE TRIGGER t_cdd_biu BEFORE INSERT OR UPDATE ON compte_depenses FOR EACH ROW EXECUTE FUNCTION trg_cdd_biu();",

# =========================
# Commentaires (conventions fichiers)
# =========================
# Convention PJ factures: Habitek_<FID>_<Fournisseur>_<DateSoumise>_<Index>.pdf
# Convention PJ comptes : Habitek_<CID>_HABITEK_<DateSoumise>_<Index>.pdf
# (Validation conseillée côté application ; stocker le chemin en clair dans file_path)
]

# --------------------------------------------------------------------
# 3) Bootstrap DB (CREATE DATABASE si manquante) + application DDL
# --------------------------------------------------------------------
def ensure_database_exists():
    admin_db = "postgres" if pg_db != "postgres" else pg_db
    conn = connect_db(admin_db)
    conn.autocommit = True
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT 1 FROM pg_database WHERE datname = %s;", (pg_db,))
            exists = cur.fetchone() is not None
            if not exists:
                create_db = sql.SQL(
                    "CREATE DATABASE {dbname} WITH ENCODING 'UTF8' TEMPLATE template0;"
                ).format(dbname=sql.Identifier(pg_db))
                cur.execute(create_db)
                print(f"✅ Base créée : {pg_db}")
            else:
                print(f"ℹ️ Base déjà existante : {pg_db}")
    finally:
        conn.close()

def apply_schema():
    conn = connect_db(pg_db)
    conn.autocommit = False
    try:
        with conn.cursor() as cur:
            for stmt in DDL_BLOCKS:
                cur.execute(stmt)
        conn.commit()
        print("✅ Schéma appliqué avec succès.")
    except Exception as e:
        conn.rollback()
        print("❌ Erreur lors de l’application du schéma :", e)
        raise
    finally:
        conn.close()

if __name__ == "__main__":
    ensure_database_exists()
    apply_schema()
