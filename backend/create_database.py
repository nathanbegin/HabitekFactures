#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import psycopg2
from psycopg2 import sql
from urllib.parse import urlparse, unquote

# --------------------------------------------------------------------
# 1) Paramètres / Connexion
# --------------------------------------------------------------------
DATABASE_URL = os.environ.get(
    "DATABASE_URL",
    "postgresql://minio:Habitek2025@localhost:5432/habitek_tresorerie"
)

parsed = urlparse(DATABASE_URL)
pg_user = unquote(parsed.username) if parsed.username else None
pg_pass = unquote(parsed.password) if parsed.password else None
pg_host = parsed.hostname or "localhost"
pg_port = parsed.port or 5432
pg_db   = (parsed.path or "/").lstrip("/") or "habitek_tresorerie"

def connect_db(dbname: str):
    return psycopg2.connect(
        dbname=dbname,
        user=pg_user,
        password=pg_pass,
        host=pg_host,
        port=pg_port,
    )

# --------------------------------------------------------------------
# 2) DDL complet (domaines, types, tables, index, fonctions, triggers)
# --------------------------------------------------------------------
DDL_BLOCKS = [

# =========================
# Domaines & Types
# =========================

# Enum statut facture
"""
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'invoice_status') THEN
    CREATE TYPE invoice_status AS ENUM ('brouillon','soumise','approuvée','payée','rejetée');
  END IF;
END $$;
""",

# Code monnaie ISO 4217, 3 lettres
"""
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'currency_iso') THEN
    CREATE DOMAIN currency_iso AS varchar(3)
      CHECK (VALUE ~ '^[A-Z]{3}$');
  END IF;
END $$;
""",

# Email (validation basique)
"""
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_addr') THEN
    CREATE DOMAIN email_addr AS varchar(320)
      CHECK (VALUE ~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$');
  END IF;
END $$;
""",

# Code postal canadien (A1A 1A1, espace facultatif)
"""
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ca_postal') THEN
    CREATE DOMAIN ca_postal AS varchar(7)
      CHECK (VALUE ~* '^[ABCEGHJ-NPRSTVXY]\\d[ABCEGHJ-NPRSTV-Z][ ]?\\d[ABCEGHJ-NPRSTV-Z]\\d$');
  END IF;
END $$;
""",

# =========================
# Tables principales
# =========================

# Budgets
"""
CREATE TABLE IF NOT EXISTS budgets (
  id              serial PRIMARY KEY,
  financial_year  varchar(4),       -- ex. 2025
  fund_type       varchar(50),
  revenue_type    varchar(255),
  amount          numeric(10,2),    -- négatif possible pour dépenses
  date_added      timestamp DEFAULT now()
);
""",

# Utilisateur (comptable)
"""
CREATE TABLE IF NOT EXISTS app_user (
  uid              integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  prénom           varchar(1000) NOT NULL,
  nom              varchar(1000) NOT NULL,
  courriel         email_addr UNIQUE,
  code_permanent   varchar(254),
  adresse          varchar(1000),
  ville            varchar(1000),
  code_postal      ca_postal,
  province         varchar(1000),
  mode_préf_remb   smallint,        -- 1 = chèque, 2 = dépôt direct
  fonction         varchar(1000),
  rôle             varchar(1000),
  CHECK (mode_préf_remb IS NULL OR mode_préf_remb IN (1,2)),
  CHECK (uid BETWEEN 1 AND 1000)   
);
""",

# Factures
"""
CREATE TABLE IF NOT EXISTS factures (
  id               bigserial PRIMARY KEY,
  fid              text UNIQUE,                          -- FYYYY-XXX (auto)
  financial_year   integer,                              -- calculé par trigger (1 mai → 30 avril)
  date_facture     timestamptz NOT NULL,
  date_soumise     timestamptz DEFAULT now(),
  date_derniere_modif timestamptz DEFAULT now(),
  fournisseur      varchar(1000) NOT NULL,
  description      varchar(1000),
  montant          numeric(12,2) CHECK (montant >= 0),
  devise           currency_iso,
  statut           invoice_status,
  catégorie        varchar(255),
  ligne_budgetaire varchar(255),
  type             varchar(255),
  ubr              varchar(255),
  poste_budgetaire varchar(255),
  uid_soumetteur   varchar(255),
  uid_approbateur  varchar(255),
  ref_cdd          text,                                  -- référence textuelle au CDD (cid)
  CHECK (fid IS NULL OR fid ~ '^F[0-9]{4}-[0-9]{3}$')
);
""",

# Comptes de dépenses
"""
CREATE TABLE IF NOT EXISTS compte_depenses (
  id                bigserial PRIMARY KEY,
  cid               text UNIQUE,                         -- CYYYY-HABITEKXXX (auto)
  financial_year    integer,                             -- calculé
  date_soumis       timestamptz DEFAULT now(),
  mode              varchar(255),
  type_cdd_int      smallint,                            -- 1 = voyage, 0 = autre
  prénom_demandeur  varchar(1000) NOT NULL,
  nom_demandeur     varchar(1000) NOT NULL,
  CHECK (type_cdd_int IS NULL OR type_cdd_int IN (0,1)),
  CHECK (cid IS NULL OR cid ~ '^C[0-9]{4}-HABITEK[0-9]{3}$')
);
""",

# Clé étrangère textuelle: factures.ref_cdd -> compte_depenses.cid (unique)
"""
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_factures_ref_cdd'
      AND table_name = 'factures'
  ) THEN
    ALTER TABLE factures
      ADD CONSTRAINT fk_factures_ref_cdd
      FOREIGN KEY (ref_cdd) REFERENCES compte_depenses (cid)
      ON UPDATE CASCADE ON DELETE SET NULL;
  END IF;
END $$;
""",

# Notes de rapport de dépenses
"""
CREATE TABLE IF NOT EXISTS notes_rdd (
  note_id       bigserial PRIMARY KEY,
  expense_pk    bigint REFERENCES compte_depenses(id) ON DELETE CASCADE,
  auteur_uid    int    REFERENCES app_user(uid) ON DELETE SET NULL,
  texte_note    text,
  date_création timestamptz DEFAULT now()
);
""",

# Pièces jointes Factures
"""
CREATE TABLE IF NOT EXISTS factures_pj (
  invoice_pk  bigint REFERENCES factures(id) ON DELETE CASCADE,
  file_index  int CHECK (file_index >= 1),
  file_path   text,
  uploaded_at timestamptz DEFAULT now(),
  PRIMARY KEY (invoice_pk, file_index)
);
""",

# Pièces jointes Comptes
"""
CREATE TABLE IF NOT EXISTS factures_cdd (
  expense_pk  bigint REFERENCES compte_depenses(id) ON DELETE CASCADE,
  file_index  int CHECK (file_index >= 1),
  file_path   text,
  uploaded_at timestamptz DEFAULT now(),
  PRIMARY KEY (expense_pk, file_index)
);
""",

# =========================
# Index utiles
# =========================
"CREATE INDEX IF NOT EXISTS idx_factures_fid ON factures(fid);",
"CREATE INDEX IF NOT EXISTS idx_compte_depenses_cid ON compte_depenses(cid);",
"CREATE INDEX IF NOT EXISTS idx_factures_finyr ON factures(financial_year);",
"CREATE INDEX IF NOT EXISTS idx_cdd_finyr ON compte_depenses(financial_year);",

# =========================
# Métadonnées : compteurs d'ID
# =========================
"""
CREATE TABLE IF NOT EXISTS id_counters (
  counter_type text NOT NULL,          -- 'facture' ou 'cdd'
  financial_year integer NOT NULL,     -- ex: 2025
  next_index integer NOT NULL DEFAULT 1,
  PRIMARY KEY (counter_type, financial_year)
);
""",

# =========================
# Fonctions utilitaires (année financière & compteurs)
# =========================

# Année financière (1 mai -> 30 avril)
"""
CREATE OR REPLACE FUNCTION fiscal_year_of(ts timestamptz)
RETURNS integer
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  y int := date_part('year', ts)::int;
  m int := date_part('month', ts)::int;
BEGIN
  IF m >= 5 THEN
    RETURN y;       -- mai à déc -> même année
  ELSE
    RETURN y - 1;   -- jan à avril -> année précédente
  END IF;
END;
$$;
""",

# Compteur atomique par type/année
"""
CREATE OR REPLACE FUNCTION next_counter(p_counter_type text, p_year integer)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
  v_next int;
BEGIN
  LOOP
    UPDATE id_counters
       SET next_index = next_index + 1
     WHERE counter_type = p_counter_type
       AND financial_year = p_year
     RETURNING next_index - 1 INTO v_next;

    IF FOUND THEN
      RETURN v_next;
    END IF;

    BEGIN
      INSERT INTO id_counters(counter_type, financial_year, next_index)
      VALUES (p_counter_type, p_year, 2); -- premier numéro renvoyé: 1
      RETURN 1;
    EXCEPTION WHEN unique_violation THEN
      -- collision concurrente -> on boucle
    END;
  END LOOP;
END;
$$;
""",

# =========================
# Triggers: Factures (FID + FY + date_derniere_modif)
# =========================

"""
CREATE OR REPLACE FUNCTION trg_factures_biu()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_year int;
  v_idx int;
BEGIN
  -- date_facture & année financière
  IF NEW.date_facture IS NULL THEN
    NEW.date_facture := now();
  END IF;
  v_year := fiscal_year_of(NEW.date_facture);
  NEW.financial_year := v_year;

  -- Génération FID à l'INSERT si absent
  IF TG_OP = 'INSERT' THEN
    IF NEW.fid IS NULL OR NEW.fid = '' THEN
      v_idx := next_counter('facture', v_year);
      NEW.fid := 'F' || v_year::text || '-' || lpad(v_idx::text, 3, '0');
    END IF;
    NEW.date_derniere_modif := now();
  ELSIF TG_OP = 'UPDATE' THEN
    -- Interdit de modifier FID
    IF NEW.fid IS DISTINCT FROM OLD.fid THEN
      RAISE EXCEPTION 'Modification de fid interdite (ancien=%, nouveau=%)', OLD.fid, NEW.fid;
    END IF;
    NEW.date_derniere_modif := now();
  END IF;

  -- Validation regex si fourni
  IF NEW.fid IS NOT NULL AND NEW.fid !~ '^F[0-9]{4}-[0-9]{3}$' THEN
    RAISE EXCEPTION 'fid invalide: % (attendu FYYYY-XXX)', NEW.fid;
  END IF;

  RETURN NEW;
END;
$$;
""",
"DROP TRIGGER IF EXISTS t_factures_biu ON factures;",
"CREATE TRIGGER t_factures_biu BEFORE INSERT OR UPDATE ON factures FOR EACH ROW EXECUTE FUNCTION trg_factures_biu();",

# =========================
# Triggers: Comptes de dépenses (CID + FY)
# =========================

"""
CREATE OR REPLACE FUNCTION trg_cdd_biu()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_year int;
  v_idx int;
BEGIN
  IF NEW.date_soumis IS NULL THEN
    NEW.date_soumis := now();
  END IF;
  v_year := fiscal_year_of(NEW.date_soumis);
  NEW.financial_year := v_year;

  IF TG_OP = 'INSERT' THEN
    IF NEW.cid IS NULL OR NEW.cid = '' THEN
      v_idx := next_counter('cdd', v_year);
      NEW.cid := 'C' || v_year::text || '-HABITEK' || lpad(v_idx::text, 3, '0');
    END IF;
  ELSIF TG_OP = 'UPDATE' THEN
    IF NEW.cid IS DISTINCT FROM OLD.cid THEN
      RAISE EXCEPTION 'Modification de cid interdite (ancien=%, nouveau=%)', OLD.cid, NEW.cid;
    END IF;
  END IF;

  IF NEW.cid IS NOT NULL AND NEW.cid !~ '^C[0-9]{4}-HABITEK[0-9]{3}$' THEN
    RAISE EXCEPTION 'cid invalide: % (attendu CYYYY-HABITEKXXX)', NEW.cid;
  END IF;

  RETURN NEW;
END;
$$;
""",
"DROP TRIGGER IF EXISTS t_cdd_biu ON compte_depenses;",
"CREATE TRIGGER t_cdd_biu BEFORE INSERT OR UPDATE ON compte_depenses FOR EACH ROW EXECUTE FUNCTION trg_cdd_biu();"
]

# --------------------------------------------------------------------
# 3) Création DB (facultatif) + Application du schéma
# --------------------------------------------------------------------
def ensure_database_exists():
    """
    Essaie de créer la base 'habitek_tresorerie' si elle n'existe pas.
    Nécessite un rôle avec CREATEDB (ou superuser). Sinon, crée la base
    manuellement puis relance ce script (il appliquera juste le schéma).
    """
    admin_db = "postgres" if pg_db != "postgres" else pg_db
    conn = connect_db(admin_db)
    conn.autocommit = True
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT 1 FROM pg_database WHERE datname = %s;", (pg_db,))
            exists = cur.fetchone() is not None
            if not exists:
                create_db = sql.SQL(
                    "CREATE DATABASE {dbname} WITH ENCODING 'UTF8' TEMPLATE template0;"
                ).format(dbname=sql.Identifier(pg_db))
                cur.execute(create_db)
                print(f"✅ Base créée : {pg_db}")
            else:
                print(f"ℹ️ Base déjà existante : {pg_db}")
    finally:
        conn.close()

def apply_schema():
    conn = connect_db(pg_db)
    conn.autocommit = False
    try:
        with conn.cursor() as cur:
            for stmt in DDL_BLOCKS:
                cur.execute(stmt)
        conn.commit()
        print("✅ Schéma appliqué avec succès.")
    except Exception as e:
        conn.rollback()
        print("❌ Erreur lors de l’application du schéma :", e)
        raise
    finally:
        conn.close()

if __name__ == "__main__":
    try:
        ensure_database_exists()
    except Exception as e:
        # Pas grave si pas de droit CREATEDB : on continue sur la base existante
        print("ℹ️ Création de base ignorée (pas de droit CREATEDB ?):", e)
    apply_schema()
